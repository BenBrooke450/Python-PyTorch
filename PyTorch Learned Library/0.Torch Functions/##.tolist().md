

# `torch.Tensor.tolist()`

### **Definition**

```python
Tensor.tolist() → built-in Python list
```

Converts a PyTorch tensor (which can be scalar, 1D, 2D, …, nD) into a **nested Python list** with the same shape.

---

# Key Behaviors

### 1. **Scalars → Python numbers**

```python
import torch
x = torch.tensor(5)
print(x.tolist())   # 5 (int, not a list)
```

If the tensor is 0D (scalar), it returns a **Python `int` or `float`**, not a list.

---

### 2. **1D tensors → flat list**

```python
x = torch.tensor([1, 2, 3])
print(x.tolist())   # [1, 2, 3]
```

---

### 3. **2D tensors → list of lists**

```python
x = torch.tensor([[1, 2, 3],
                  [4, 5, 6]])
print(x.tolist())
# [[1, 2, 3], [4, 5, 6]]
```

---

### 4. **3D (or higher) tensors → nested lists**

```python
x = torch.arange(8).reshape(2, 2, 2)
print(x)
# tensor([[[0, 1],
#          [2, 3]],
#         [[4, 5],
#          [6, 7]]])

print(x.tolist())
# [[[0, 1], [2, 3]], [[4, 5], [6, 7]]]
```

---

### 5. **Preserves data type as Python native types**

* `float32` → Python `float`
* `int64` → Python `int`
* `bool` → Python `bool`

Example:

```python
x = torch.tensor([True, False, True])
print(x.tolist())   # [True, False, True]
```

---

# Comparison with Other Methods

### `.numpy()` vs `.tolist()`

* `.numpy()` → returns a NumPy array (`ndarray`), still optimized for numerical ops.
* `.tolist()` → returns pure Python lists (slower for math, but serializable).

```python
x = torch.tensor([1, 2, 3])

print(x.numpy())   # array([1, 2, 3])
print(x.tolist())  # [1, 2, 3]
```

---

# When to Use `.tolist()`

✅ Useful when:

* You want to **serialize** tensors (e.g., save to JSON).
* You need a **pure Python object** for APIs that don’t accept tensors or NumPy arrays.
* Debugging / pretty printing small tensors.

Not ideal when:

* You still plan to do math → better to keep tensor or NumPy array (faster).
* Large tensors → `.tolist()` creates big nested lists, slower and memory-hungry.

---

# Summary

* **Scalars** → Python number (`int`/`float`/`bool`).
* **n-D tensors** → nested Python lists of depth `n`.
* Preserves values as Python native types.
* Best for serialization, interop with pure Python.
* Avoid for large tensors if performance matters.

